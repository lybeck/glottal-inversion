% A routine that computes the reconstruction of the glottal excitation
% signal according to the vowel data generated by create_simulated_data.
% By default the routine will plot the reconstruction of the glottal
% excitation signal, and optional outputs include playing the glottal
% excitation signal and saving both the sound data and plot data of the
% reconstruction. Files required by the routine are (all located in a data folder)
% -data.mat (generated by create_simulated_data)
% -filter_male_a.mat
% -constants.mat
%
% See also CREATE_SIMULATED_DATA, TIK_A_INV, MOROZOV



%clear

load data/data m x yd periods Q_data noise_lvl noise_factor f data_male_filter

if data_male_filter
    filt = load('data/filter_male_a');
else
    filt = load('data/filter_female_a');
end

const = load('data/constants');

% filter used for inversion
% 0: female filter
% 1: male filter
male_filter = 1;

% play sound from reconstruction?
play_sound = 0;

% save sound file from reconstruction?
save_sound = 0;

% is there an inverse crime?
inverse_crime = ~xor(data_male_filter, male_filter);

% plot and save results of reconstructions during the iterations Q
% approximation? A check of existence of previous results will be made.
plot_and_save = 1;

% show plots?
show_plots = 1;

filename = ['crime-', num2str(inverse_crime), '_',...
            'Q-', num2str(round(Q_data * 100)), '_',...
            'f-', num2str(round(f)), '_',...
            'noise-', num2str(round(noise_lvl * 100))];        
if plot_and_save
    [folder, overwrite] = create_results_folder(filename);
    if ~overwrite
        return;
    end
    filename = [folder, '/', filename];
    disp(['Saving results to directory: ' filename]);
end

% pause execution after single plot?
pause_exec = 0;

% the magic constant, and the least allowed magic value
magic_constant = .15;
least_magic = .04;

% Initial guess of Q parameter. In the automatic approximation process,
% Q_guess should equal 1.
Q_guess = 1;

% Max iteration count for the iterations in the automatic approximation
% function of Q
iterations = 5;

samples_per_period = length(x) / periods;

for ii=1:iterations
    
    fprintf('Starting iteration %d with Q_guess = %.3f...\n', ii, Q_guess)
    
    % noise multiplier due to error in filter
    % if the data is created with inverse crime, noise_level and
    % noise_factor need to be sent to the funtion
    if inverse_crime
        noise_est = estimate_noise(m, f, Q_guess, periods, noise_lvl, noise_factor);
    else
        noise_est = estimate_noise(m, f, Q_guess, periods);
    end
    
    % alpha-estimation
    x0 = zeros(length(m), 1);
    delta = delta_fun(length(m), noise_est);
    alpha = morozov(create_filter_matrix(filt.alpha, length(m)), m, delta, 1);
    
    % creating the reconstruction with Tikhonov regularization strategy
    rec = Tik_a_inv(m, alpha, x0, periods, Q_guess, male_filter);

    %plotting
    [relerr, relerrv, shape_err, shape_err_fac] = calculate_statistic(filt, rec, yd);
    
    if show_plots

        plot_results(filename, ii, x, rec, yd, relerr, relerrv, alpha, Q_data, Q_guess,...
            periods, noise_lvl, noise_factor, f, data_male_filter, plot_and_save);
        if pause_exec
            pause;
            close all;
        else
            pause(2);
        end

    end
    
    % get new guess for the klatt variable
    if ii ~= iterations
        
        rec_period = rec(1:samples_per_period);
        [~, ind] = min(rec_period);
        Q_guess_new = ind / samples_per_period + magic_constant;
        
        if Q_guess_new >= Q_guess
            break;
        end
        
        Q_guess = Q_guess_new;
        
        % check that the guess is valid
        if Q_guess > 1
            Q_guess = 1;
        end
        
        % decrease magic constant
        magic_constant = 2/3 * magic_constant;
        if magic_constant < least_magic
            magic_constant = least_magic;
        end
    end
    
end

% calculate the relative error in the frequency domain
yd_fft = abs(fft(yd));
rec_fft = abs(fft(rec));
x_fft = 1:length(rec_fft);
relerr_fft = compute_relerr(rec_fft, yd_fft);

fprintf('\n')
fprintf('Alpha used in calculations         : %.2f\n', alpha)
fprintf('Relative error on glottal impulse  : %g %%\n', relerr)
fprintf('Relative error in frequency domain : %g %%\n', relerr_fft)
fprintf('Relative error on vowel            : %g %%\n\n', relerrv)
% sound
if play_sound || save_sound
    
    % sound duration in seconds
    d = 1;
    
    % repetitions
    rep = round(d / x(end));
    
    recyd = repmat(rec, rep, 1);
    syd = repmat(yd, rep, 1);
    recvow = filter(1, filt.alpha, recyd);
    vow = filter(1, filt.alpha, syd);
    recyd = recyd / max(abs(recyd));
    recvow = recvow / max(abs(recvow));
    syd = syd / max(abs(syd));
    vow = vow / max(abs(vow));
    if play_sound
        
        sound(syd, const.fs)
        pause(2)
        sound(recyd, const.fs)
        pause(3)
        
        sound(vow, const.fs)
        pause(2)
        sound(recvow, const.fs)
    end

    if save_sound
        
        extension = '.wav';
        
        audiowrite([filename, 'glottal_impulse_data', extension], syd, const.fs);
        audiowrite([filename, 'glottal_impulse_rec', extension], recyd, const.fs);
        audiowrite([filename, 'vowel_data', extension], vow, const.fs);
        audiowrite([filename, 'vowel_rec', extension], recvow, const.fs);
    end
end
